# ![logo](img/logo_small.png){: style="width:39px" } Dokumentace

Toto je hlavn√≠ ƒç√°st dokumentace, popisuj√≠c√≠ **co a jak**.
V dal≈°√≠ch ƒç√°stech, p≈ôedev≈°√≠m pak v odd√≠le **Workshopy / tutori√°ly** se pak dozv√≠te **jak na to**.

Origin√°ln√≠ dokumentaci k MicroPythonu najdete na str√°nk√°ch ü°í [docs.micropython/esp32](http://docs.micropython.org/en/latest/esp32/quickref.html)

---

## Moduly, t≈ô√≠dy, funkce

!!! attention "Z√°klad pro dal≈°√≠ pochopen√≠ (Micro)Pythonu"
    T√©mƒõ≈ô v≈°e v Pythonu je objekt. **Objekt** je kolekce dat (promƒõnn√Ωch) a **metod** (funkc√≠), kter√© s dan√Ωmi daty pracuj√≠. Prototypem objekt≈Ø jsou **t≈ô√≠dy**, z nich≈æ jsou v≈°echny **objekty** (ƒç√≠sla, ≈ôetƒõzce, funkce, moduly, metody, atp) odvozeny coby **instance**.
    Pokud v√°m to nen√≠ jasn√©, trochu podrobnƒõji se o tom rozepisujeme na samostatn√© str√°nce: [class()](/class).
    Pro spr√°vn√© pochopen√≠ a p≈ôedev≈°√≠m v kontextu pr√°ce s hardware zaƒç√°teƒçn√≠k≈Øm doporuƒçujeme zm√≠nƒõn√Ω odkaz alespo≈à letmo nav≈°t√≠vit.

!!! note
      Toto nen√≠ v√Ωuka programov√°n√≠ ‚Äì ale jen uk√°zky a experimenty s p≈ôihl√©dnut√≠m na sadu knihoven a modul≈Ø **octopusLab** pro pr√°ci s vybran√Ωm HW.

      Pro podrobnƒõj≈°√≠ proniknut√≠ do taj≈Ø programov√°n√≠ v Pythonu doporuƒçujeme: 

      - [naucse.python.cz](https://naucse.python.cz/)
      - [naucse.python.cz/course/mi-pyt/intro/micropython](https://naucse.python.cz/course/mi-pyt/intro/micropython/)
      - [howto.py.cz](http://howto.py.cz/index.htm)

---

### Knihovny (components | utils | lib)

Jednotliv√© moduly - knihovny (podprogramy, t≈ô√≠dy) jsme rozdƒõlili do nƒõkolika z√°kladn√≠ch adres√°≈ô≈Ø:

- [/components](#octopus-components), kam postupnƒõ p≈ôid√°v√°me jednotliv√© "osamostatnƒõl√©" komponenty.

- [/lib](#octopus-lib), kde jsou p≈ôev√°≈ænƒõ knihovny t≈ôet√≠ch stran, a mal√© fragmenty, kter√© maj√≠ v√Ωhodu, ≈æe se p≈ôi importu v adres√°≈ôi lib hledaj√≠, **Micropython** je nalezne bez ud√°n√≠ cesty k nim.

- [/utils](#octopus-utils), (utility) moduly octopusLAB, a t≈ô√≠dy pro pr√°ci s periferiemi.

*U≈æivatele vlastnƒõ nemus√≠ zaj√≠mat, kde to je ulo≈æeno, a tak na to d≈Øraz neklademe, jen je vhodn√© si to pohl√≠dat p≈ôi sestavov√°n√≠ vƒõt≈°√≠ch projekt≈Ø.*

!!! hint "**Zdroje programov√©ho k√≥du**"
    `Github` => `stable.tar` => `docs`
    
    Na≈°√≠ snahou je udr≈æet v souladu zdroj z githubu: [github.com/octopusengine/octopuslab](https://github.com/octopusengine/octopuslab/tree/master/esp32-micropython), kter√Ω se po *kompilaci a komprimaci* stane [stable.tar](/install/#system-download-deploy) a k nƒõmu udr≈æovat aktu√°ln√≠ **dokumentaci**.

---

### Adres√°≈ôov√° strukrura na ESP32

<pre>
|-- <a href="#soubory-bootpy-a-mainpy">boot.py</a>       # inicializace po startu
|      |-- <a href="#reset">reset</a>
|-- <a href="#soubory-bootpy-a-mainpy">main.py</a>       # hlavn√≠ soubor programu
|-- /assets       # obr√°zky, zvuky, tabulky
|-- <a href="#config">/config</a>       # kofiguraƒçn√≠ soubory (.json)
|-- <a href="#octopus-lib">/lib</a>          # obecnƒõ dostupn√° knihovna (lib)
|      |-- <a href="#pubsub">pubsub</a>
|      |-- <a href="/ftp">FTP</a>
|      |-- <a href="#BLE">/blesync_uart</a>
|      |-- ...
|      |-- /bmp280   # i2c Atmospheric pressure sensor
|      |-- /bh1750   # i2c Light sensor
|      |-- <a href="#st7735">ST7735.py</a> # TFT128*166 color display
|      |-- colors_rgb.py
|      |-- <a href="#hcsr04">hcsr04.py</a> # ultrasonic
|      |-- <a href="#lcd">lcd</a>
|      |-- ...
|
|-- <a href="#octopus-components">/components</a>
|      |-- <a href="#led">led</a>
|      |-- <a href="#rgb">rgb</a>
|      |-- <a href="#analog">analog</a>
|      |-- <a href="#button">button</a>
|      |-- <a href="#display7">display7</a>
|      |-- <a href="#oled">oled</a>
|      |-- <a href="#buzzer">buzzer</a>
|      |-- <a href="#servo">servo</a>
|      |-- <a href="#dcmotors">dcmotors</a>
|      |-- [plc]
|      |-- <a href="#iot">iot</a>
|            | Relay | PWM | Thermometer
|
|-- <a href="#octopus-utils">/utils</a>
|      |-- <a href="/setup">setup</a>
|      |-- <a href="#octopus_lib">octopus_lib</a>
|            | <a href="#i2c">I2C</a> | <a href="#spi">SPI</a> | <a href="#lcd">LCD</a> | <a href="#rtc">RTC</a> | ...
|      |-- <a href="#wificonnect">WiFiConnect</a>
|      |-- <a href="#pinout">pinout</a>
|      |-- <a href="#bits">bits</a>
|      |-- <a href="#transform">transform</a>
|      |-- <a href="#database">database</a>
|      |-- <a href="#mqtt">mqtt</a>
|      |-- octopus # WorkFrame with WebServer
|      |-- ...
|      |-- BLE
|
|-- <a href="/pinouts">/pinouts</a>      # nastaven√≠ pin≈Ø
|-- <a href="/examples">/examples</a>      # uk√°zky
|      |-- /asyncio
|      |-- /ble
|      |-- /param
|      |-- /pubsub
|      |-- blink.py
|      |-- ...
|
|-- /tests
|
|-- /shell
|      |-- <a href="/upyshell">shell</a>
|      |-- <a href="/upyshell/#editor">editor</a>
|-- ...
</pre>

!!! warning "**Pozor**"
    **Pokud jste pou≈æ√≠vali n√°≈° syst√©m u≈æ v roce 2019**, p≈ôeinstalujte si na novou verzi. Velk√° ƒç√°st syst√©mu by v√°m u≈æ nefungovala. Od t√© doby do≈°lo toti≈æ k ≈ôadƒõ zmƒõn. P≈ôedev≈°√≠m byly t≈ôi z√°sadn√≠ verze Micropythonu, kde se mƒõnil i form√°t "kompilovan√Ωch" soubor≈Ø `.mpy`, kter√© jsou z√°kladem na≈°√≠ distribuce. Tak√© se doplnilo `BLE` pro pr√°ci s **BlueTooth low energy**.
    A dal≈°√≠ zmƒõnou byla velk√° `refaktorizace` syst√©mu **octopus**, kde podardes√°≈ô `util` byl rozdƒõlen na `utils` (pro SW utility a hlavn√≠ framework) a `components` (kde jsou p≈ôev√°≈ænƒõ knihovny pro hw komponenty a periferie.) Tak√© `shell` byl p≈ôesunut z `util/shell` do rootu.


### Soubory boot.py a main.py

#### ‚Ä¢ boot.py 
je soubor, kter√Ω se spou≈°t√≠ jako prvn√≠ po bezprost≈ôen√≠m startu nebo po resetu ESP. Zpravidla ho nemƒõn√≠me. Mƒõl by obsahovat z√°kladn√≠ obecnou inicializaci. My tam m√°me p≈ôedev≈°√≠m definice cest k modul≈Øm:

```python
# boot.py
def setup():
    import utils.setup
    utils.setup.setup()

def octopus():
    import utils.octopus
    utils.octopus.octopus()
    return utils.octopus

def reset():
    from machine import reset
    reset()

def shell():
    import shell
    shell.shell()
```

##### Reset

Pro zjednodu≈°en√© pou≈æit√≠ resetu pomoc√≠ p≈ô√≠kazu `reset()` je v `boot.py` p≈ôednastaveno:
```python
def reset():
    from machine import reset
    reset()
```

---

#### ‚Ä¢ main.py 
je hlavn√≠ soubor u≈æivatelsk√©ho programu, kter√Ω budeme vyu≈æ√≠vat pro sv√© projekty. Spust√≠ se (pokud existuje) hned po `boot.py`.
ƒåasto pou≈æ√≠v√°me jednoduch√© kop√≠rov√°n√≠ existuj√≠c√≠ho programu nebo uk√°zky (z examples) v prost≈ôed√≠ [uPyshell](/upyshell):

```batch
$ cp examples/blink.py main.py

```

---

## OCTOPUS Components

### ![hwsoc](img/hwsoc.png){: style="width:28px" } Led
T≈ô√≠da `Led` je vlastnƒõ jen jednoduch√Ωm roz≈°√≠≈ôen√≠m t≈ô√≠dy `Pin`.
Parametr p≈ôi vytv√°≈ôen√≠ instance je ƒç√≠slo pinu. `led = Led(2)`
P≈ôidali jsme k z√°kladn√≠ metodƒõ `value()` dal≈°√≠ch nƒõkolik metod: `toggle()`, `blink()` 


Zdrojov√Ω k√≥d knihovny:
[./components/led](https://github.com/octopusengine/octopuslab/blob/master/esp32-micropython/components/led/__init__.py)

Nejkrat≈°√≠ varianta pou≈æit√≠ je sice s vyu≈æ√≠t√≠m `utils`:
```python
from utils.octopus import led
led.value(1)
```

Ale pro projekt lep≈°√≠ verze je s `components` (≈°et≈ô√≠ pamƒõ≈•, proto≈æe nanaƒç√≠t√° "cel√Ω octopus"):
```python
from components.led import Led
led = Led(2)

while True:
    led.blink()
```

```python
dir(led)
['class', 'init', 'module', 'qualname', 'value', 'dict', 'pin', 'blink', 'toggle', 'state']

>>> led.pin
> Pin(2)
>>> led.state
> False
>>> led.value(1) # sv√≠t√≠
>>> led.state    # info o stavu
1
```

**. TAB nab√≠dka metod:** 
Micropython m√° obrovskou v√Ωhodu v tom, ≈æe bƒõ≈æ√≠ jako interpret: kdy≈æ u≈æivatel nap√≠≈°e n√°zev promƒõnn√© nebo instance objektu, skoro v≈°echno se o nich m≈Ø≈æeme dozvƒõdƒõt. Napi≈°te `led` pak `.` (teƒçka) a stisknƒõte `TAB`:
```
led.
class       init        module      qualname
value       dict        pin         blink
toggle      state
```
!!! note "**note**"
    Pro obecnƒõj≈°√≠ pr√°ci s vyu≈æit√≠m `set_pinout()` (p≈ôeddefinovan√Ωch [pin≈Ø](/#pinout)) a `io_config` p≈ôedpokl√°d√°me, ≈æe pro [Octopus FrameWork](/framework) m√°te pomoc√≠ [setup()](/setup) nastavenu desku `ds` a perif√©rie `ios`.

ƒå√≠slo PINu v uk√°zce je 2, to je sv√≠tiv√° dioda vestavƒõn√° v **DoIt** modulech i v na≈°em ESP32boardu. Ale pro pr√°ci s obecn√Ωm modulem, kde m√°me mo≈ænost si nastavit, kde se Led dioda nach√°z√≠, pou≈æijeme pak variantu z√°kladn√≠ uk√°zky z examples, kde `BUILT_IN_LED` je konstanta, ve kter√© je ƒç√≠slo PINu ulo≈æeno:

```python
from components.led import Led
from utils.pinout import set_pinout

pinout = set_pinout()           # set board pinout
led = Led(pinout.BUILT_IN_LED)  # BUILT_IN_LED = 2

print("---examples/blink.py---")
# start main loop

while True:
    led.blink()
```

ü°í [pinout](#pinout)

---

### ![hwsoc](img/hwsoc.png){: style="width:28px" } Rgb
Knihovna pro *plnobarevn√©* **RGB led** je vytvo≈ôena p≈ôedev≈°√≠m pro pr√°ci s adresovatel√Ωm modulem typu **WS2812b** (*proto se pou≈æ√≠v√° zkratka WS*). Na≈°e verze je roz≈°√≠≈ôen√≠m vestavƒõn√© t≈ô√≠dy `NeoPixel`. *Pro ≈ô√≠zen√≠ klasick√Ωch R-G-B diod je pot≈ôeba na ka≈ædou barevnou slo≈æku samostatn√Ω PIN, co≈æ vyu≈æ√≠v√°me jen ojedinƒõle, jeliko≈æ voln√Ωch PIN≈Ø na ESP u≈æ moc nezb√Ωv√°.*

Zdrojov√Ω k√≥d knihovny `Rgb` ü°í [components/rgb](https://github.com/octopusengine/octopuslab/blob/master/esp32-micropython/components/rgb/__init__.py) (*slou≈æ√≠ i jako uk√°zka, jak lze t≈ô√≠du roz≈°√≠≈ôit*)

T≈ô√≠da je roz≈°√≠≈ôena o nƒõkter√© nov√© metody:

- `color(color)` # pro jednu LED diodu, color ve form√°tu (R,G,B), 0-255
- `color(color, index)` # pro v√≠ce modul≈Ø, indexov√°no
- `simpleTest()` # probƒõhne R, G, B
- `wheel()` # z ƒç√≠sla vygeneruje barvu
- `random_color()` # n√°hodn√° barva
- `rainbow_cycle()` # duha


```python
from components.rgb import Rgb
ws = Rgb(15) # BUILT_IN_RGB (WS) ROBOTboard
ws.color((255,0,0)) # R G B => RED

ws.simpleTest()

import colors_rgb as rgb # definice barev v /lib - BLACK (nesv√≠t√≠)
ws.color(rgb.BLUE)       # zobrazen√≠ barvy, rgb.RED/rgb.GREEN ...


```

!!! note "**note**"
    Pro obecnƒõj≈°√≠ pr√°ci s vyu≈æit√≠m `set_pinout()` (p≈ôeddefinovan√Ωch [pin≈Ø](/#pinout)) a `io_config` p≈ôedpokl√°d√°me, ≈æe pro [Octopus FrameWork](/framework) m√°te pomoc√≠ [setup()](/setup) nastavenu desku `ds` a perif√©rie `ios`.

N√°sleduj√≠c√≠ uk√°zka naznaƒçuje komplexnƒõj≈°√≠ pr√°ci s p≈ôedkonfigurovan√Ωmi konstantamy, kter√© urƒçuj√≠ na kter√©m pinu (`pinout.WS_LED_PIN`) a kolik modul≈Ø m√°me (`io_conf.get('ws')`).

```python
from components.rgb import Rgb

from utils.pinout import set_pinout
pinout = set_pinout()   # set board pinout

from utils.io_config import get_from_file
io_conf = get_from_file()

ws = Rgb(pinout.WS_LED_PIN,io_conf.get('ws'))

print("---examples/rgb_blink.py---")
ws.simpleTest()
```

Zdrojov√Ω k√≥d uk√°zky: [examples/rgb_blink.py](https://github.com/octopusengine/octopuslab/blob/master/esp32-micropython/examples/rgb_blink.py)

Pro bƒõ≈ænou pr√°ci je v prvn√≠ f√°zi snadnƒõj≈°√≠ pou≈æ√≠t p≈ôedchoz√≠ variantu, ale pro rozs√°hlej≈°√≠ projekty a pr√°ci v t√Ωmu se mus√≠ zdokumentovat pou≈æit√≠ "magick√© konstanty" **15** v definici `ws = Rgb(15)`.

ü°í [pinout](#pinout)

---

### ![hwsoc](img/hwsoc.png){: style="width:28px" } Analog
Tento modul je pro pr√°ci s analogov√Ωm vstupem pomoc√≠ DAC p≈ôevodn√≠ku. Opƒõt se jedn√° o roz≈°√≠≈ôen√≠ z√°kladn√≠ t≈ô√≠dy `ADC`, kde vytvo≈ôen√≠m instance s parametrem vstupn√≠ho PINu zjednodu≈°ujeme celou inicializaci na `an = Analog(33)`. Z√°kladn√≠ metodu `read()` jsme roz≈°√≠≈ôili o `get_adc_aver(num)`, kde poƒç√≠t√°me pr≈Ømƒõr z *num* nemƒõ≈ôen√Ωch hodnot.


Zdrojov√Ω k√≥d knihovny: [components/analog](https://github.com/octopusengine/octopuslab/blob/master/esp32-micropython/components/analog/__init__.py)

```python
from time import sleep
from components.analog import Analog

an2 = Analog(33)

while True:
    data =  an2.get_adc_aver(8)
    print(data)
    sleep(5)
```

---


### ![hwsoc](img/hwsoc.png){: style="width:28px" } Button
Pro z√°kladn√≠ pr√°ci s tlaƒç√≠tky. P≈Øvodnƒõ jsme pou≈æ√≠vali samostatn√Ω blok s p≈ôeru≈°en√≠m, ale knihovna pak byla p≈ôeps√°na tak, ≈æe vyu≈æ√≠v√° dekor√°tor `@led_button.on_press`, kter√Ωm uvedeme (odekorujeme) vlastn√≠ funkci `on_press_top_button()`, kter√° se vyvol√° v≈ædy, kdy≈æ se zm√°ƒçkne tlaƒç√≠tko. Cel√° funkce pak bƒõ≈æ√≠ na pozad√≠, je neblokuj√≠c√≠, a snadno i spolehlivƒõ se d√° pou≈æ√≠t i pro v√≠ce tlaƒç√≠tek.


Zdrojov√Ω k√≥d knihovny: [components/button](https://github.com/octopusengine/octopuslab/blob/master/esp32-micropython/components/button/__init__.py)


```python
from machine import Pin
from components.button import Button

boot_pin = Pin(0, Pin.IN)
boot_button = Button(boot_pin, release_value=1)


@boot_button.on_press
def boot_button_on_press():
    print('boot_button_on_press')


@boot_button.on_long_press
def boot_button_on_long_press():
    print('boot_button_on_long_press')


@boot_button.on_release
def boot_button_on_release():
    print('boot_button_on_release')

```

Star√° verze 1.0 mƒõla v konstruktoru ƒç√≠slo PINu.
Nov√° verze 2.0 m√° p≈ô√≠mo instanci PINu.

```python
from time import sleep
from machine import Pin
from components.button import Button

led_button = Button(0, release_value=1)
built_in_led = Pin(2, Pin.OUT)

built_in_led.on()
sleep(1)
built_in_led.off()

@led_button.on_press
def on_press_top_button():
    print("on_press_top_button")
    built_in_led.on()
    sleep(3)
    built_in_led.off()
```

ü°í [Led](#led) | [@Dekor√°tor](#dekorator)

Pr√°ce se ƒçty≈ômi tlaƒç√≠tky (na ESP32board) - v uk√°zce je zakomentov√°na spolupr√°ce s displejem `tft` ü°í [st7735](#st7735)

```python
from utils.pinout import set_pinout
pinout = set_pinout()

from components.button import Button
from utils.transform import Point2D

print("buttons init>")
button_dwn = Button(34, release_value=1)
button_top = Button(36, release_value=1)
button_lef = Button(35, release_value=1)
button_rig = Button(39, release_value=1)

# size = 3
cursor = Point2D(63,81) # center TFT128*166 dispaly (mod 3)

def position(dx,dy):
    global mx # cursor, fb, tft
    cursor.x = cursor.x + dx*3
    cursor.y = cursor.y + dy*3

    print(cursor.x,cursor.y)
    # fb.fill(color565(*BLACK))
    # tft.blit_buffer(fb, 0, 0, tft.width, tft.height)
    # tft.fill_rectangle(cursor.x,cursor.y, 6, 6, color565(*RED))


@button_dwn.on_press
def on_press_dwn():
    print("down")
    position(0,1)

@button_top.on_press
def on_press_top():
    print("top")
    position(0,-1)

@button_lef.on_press
def on_press_lef():
    print("left")
    position(-1,0)

@button_rig.on_press
def on_press_rig():
    print("right")
    position(1,0)

```

---

### ![hwsoc](img/hwsoc.png){: style="width:28px" } Display7
Osm sedmisegmentovek s obvodem MAX na sbƒõrnici `SPI` je do zaƒç√°tku ide√°ln√≠ displej pro z√°klady pr√°ce s mikrokontrol√©rem. M√° "retro" sedm segment≈Ø pro zobrazen√≠ ƒç√≠sel - proto `disp7`. Obdobn√Ω modul se shodn√Ωm ovladaƒçem je matice 8x8 sv√≠tiv√Ωch diod, ten jsme pojmenovali `disp8`.

Zdrojov√Ω k√≥d [components/display7](https://github.com/octopusengine/octopuslab/tree/master/esp32-micropython/components/display7)

P≈ôed inicializac√≠ se mus√≠ nejd≈ô√≠ve p≈ôipojit `SPI`. V n√°sleduj√≠c√≠ uk√°zce je "dvojitƒõ" zakomentovan√° `##` obecnƒõj≈°√≠ metoda a pou≈æit√° je `spi_init()` z knihovny `octopus_lib`.


```python
from machine import Pin, SPI
from components.display7 import Display7
## from utils.pinout import set_pinout
from utils.octopus_lib import spi_init

print("this is simple Micropython example | octopusLAB & ESP32")

print("--- spi-init ---")
## pinout = set_pinout()
## spi = SPI(1, baudrate=10000000, polarity=1, phase=0, sck=Pin(pinout.SPI_CLK_PIN), mosi=Pin(pinout.SPI_MOSI_PIN))
spi = spi_init()

ss = Pin(pinout.SPI_CS0_PIN, Pin.OUT)
#spi.deinit() #print("spi > close")

print("--- display7-init ---")
d7 = Display7(spi, ss) # 8 x 7segment display init
d7.write_to_buffer('octopus')
d7.display()

```

Nejkrat≈°√≠ variantou je **octopus framework** verze, kde je ale nutno m√≠t p≈ôes `setup()` a `ds` nastavenu desku (nƒõjƒçastƒõji ROBOTboard nebo ESP32board) a d√°le pomoc√≠ `ios` nastaveno `disp7` (4 | 1)

```python
from time import sleep
from utils.octopus import disp7_init

print("this is simple Micropython example | ESP32 & octopusLAB")
print()

d7 = disp7_init()	# 8 x 7segment display init

for i in range(999):
    d7.show(1000-i)
    sleep(1)
```

---
### ![hwsoc](img/hwsoc.png){: style="width:28px" } Oled
Obl√≠bili jsme si tak√© mal√Ω 128x64px monochromatick√Ω OLED displej. Jeho p≈ô√≠m√© pou≈æ√≠t√≠ vy≈æaduje u≈æ i inicializaci I2C a dal≈°√≠ drobnosti, proto jsme vƒõt≈°inou vyu≈æ√≠vali knihovny octopus.
Ale uk√°zalo se, ≈æe pro vlastn√≠ projekty je lep≈°√≠ umƒõt spou≈°tƒõt displej i "samostatnƒõ", co≈æ je v uk√°zce:
[examples/test_oled.py](https://github.com/octopusengine/octopuslab/blob/master/esp32-micropython/examples/test_oled.py)

Zjednodu≈°en√© ovl√°d√°n√≠ je pak tradiƒçnƒõ:
```python
from utils.octopus import oled_init
oled = oled_init()
...
```

Z√°klad ale vych√°z√≠ z knihovny `ssd1306`, kter√° je u≈æ souƒç√°st√≠ Micropythonu:
```python
def oled_init():

    from utils.pinout import set_pinout
    from machine import Pin, I2C
    import ssd1306

    # pinout = set_pinout()
    # i2c = I2C(0, scl=Pin(pinout.I2C_SCL_PIN), sda=Pin(pinout.I2C_SDA_PIN), freq=100000)
    from utils.octopus_lib import i2c_init
    i2c = i2c_init()

    oled = ssd1306.SSD1306_I2C(128, 64, i2c, 0x3c)
    return oled

oled = oled_init()
oled.text("octopusLAB", 0, 0)
oled.show()

oled.draw_image() # default /assets/octopus_image.pbm
oled.invert(0)
...
```

```python
>>> from assets.icons9x9 import ICON_clr, ICON_heart
>>> oled.draw_icon(ICON_heart,115,15) 

>>> def heartBeat()               
...    oled.draw_icon(ICON_heart,115,15)
...    sleep(1)
...    oled.draw_icon(ICON_clr,115,15)
...    sleep(1)
...
```

---


### ![hwsoc](img/hwsoc.png){: style="width:28px" } Buzzer

Pasivn√≠ piezo "p√≠p√°k" slou≈æ√≠ pro akustick√° upozornƒõn√≠, ale um√≠ p≈ôehr√°t i velmi jednoduch√© "retro" melodie.

Zdrojov√Ω k√≥d knihovny: [components/buzzer](https://github.com/octopusengine/octopuslab/tree/master/esp32-micropython/components/buzzer)

Z√°klad pr√°ce:
```python
from components.buzzer import Buzzer
piezzo = Buzzer(33)
piezzo.beep()
```

Dopl≈àuj√≠c√≠ t≈ô√≠da `melody` jako p≈ôid√°n√≠ dal≈°√≠ ƒç√°sti k√≥du:
```python
from components.buzzer.melody import jingle1
piezzo.play_melody(jingle1)
```

---


### ![hwsoc](img/mchtr.png){: style="width:28px" } Servo
Modul pro pr√°ci se servem, opƒõt vytvo≈ôen√≠m instance na dan√©m PINu (mus√≠ b√Ωt PWM).
Hlavn√≠ metodou je pak pootoƒçen√≠ na dan√Ω √∫hel:  `set_degree()`.

Zdrojov√Ω k√≥d knihovny: [components/servo](https://github.com/octopusengine/octopuslab/blob/master/esp32-micropython/components/servo/__init__.py)

```python
from time import sleep
from utils.pinout import set_pinout

from components.servo import Servo
pinout = set_pinout()

# s1 = Servo(pinout.PWM1_PIN)
# s2 = Servo(pinout.PWM2_PIN)
s3 = Servo(pinout.PWM3_PIN)

angles = [0, 20, 50, 70, 90]

while True:
    for a in angles:
        s3.set_degree(a)
        sleep(1)
```


#### pca9685

Element√°rn√≠ z√°klad pr√°ce s v√≠ce servy pomoc√≠ I2C expand√©ru pca9685: 

```python
from pca9685.servo import Servos
from utils.octopus_lib import i2c_init
from time import sleep_ms
from utils.transform import * # include all - only for example


# blocking - simple test
def sweep(s, start, stop, delay=5, step=1):
   ang = start
   servo.position(s, ang)
   sleep_ms(delay)

   if start < stop:
      print("a")
      while ang < stop:
         ang = ang + step
         servo.position(s, ang)
         sleep_ms(delay)

   if start > stop:
      print("b")
      while ang > stop:
         ang = ang - step
         servo.position(s, ang)
         sleep_ms(delay)


i2c = i2c_init(1)
servo = Servos(i2c)


def sweeptest():
    sweep(0,30,160)
    sweep(1,30,180)
    sweep(0,160,30)
    sweep(1,180,30)
    
sweeptest()
```

Zdrojov√Ω k√≥d uk√°zky:
https://github.com/octopusengine/octopuslab/blob/master/esp32-micropython/examples/pca9685.py

Pro tranformace a kompletnƒõj≈°√≠ pr√°ci s v√≠ce servy vyv√≠j√≠me knihovnu `transform`:
https://github.com/octopusengine/octopuslab/blob/master/esp32-micropython/utils/transform.py


ü°í [pinout](#pinout)

---


### ![hwsoc](img/mchtr.png){: style="width:28px" } DCmotors

Zdrojov√Ω k√≥d knihovny: [components/dcmotors](https://github.com/octopusengine/octopuslab/blob/master/esp32-micropython/components/dcmotors/__init__.py)

```python
from utils.pinout import set_pinout
pinout = set_pinout()

from components.dcmotors import Motor, Steering

motor_r = Motor(pinout.MOTOR_1A, pinout.MOTOR_2A, pinout.MOTOR_12EN)
motor_l = Motor(pinout.MOTOR_3A, pinout.MOTOR_4A, pinout.MOTOR_34EN)
steering = Steering(motor_l, motor_r)
speed = 800

steering.center(0)
steering.center(-speed)
steering.right(speed)
steering.left(speed)
```

---


### ![hwsoc](img/wsetup.png){: style="width:28px" } IoT

T≈ô√≠da, kter√° p≈Øvodnƒõ slou≈æila jako modul pro IoTboard, ale samostatn√° zahrnuje rel√© a PWM MOS-FET ≈ô√≠zen√≠.

Zdrojov√Ω k√≥d knihovny: [components/iot](https://github.com/octopusengine/octopuslab/tree/master/esp32-micropython/components/iot)

Uk√°zka: 
```python
from components.iot import Relay
re1 = Relay() # default IoTboard pin 
re1.value(1)
re2 = Relay(26)


from components.iot import Pwm
pwm_led = Pwm(33)
pwm_led.duty(300)


from components.iot import Thermometer
tt = Thermometer(32)  # DEV1 pin (ROBOTboard)
tx = tt.ds.scan()  # get list of all Dallas sensors
tt.get_temp()  # default index 0 -> first sensor
tt.get_temp(0)  # first sensor explicitly
```

---

## OCTOPUS Utils

### ![hwsoc](img/bits.png){: style="width:28px" } WiFiConnect

Hlavn√≠ v√Ωhodou na≈°eho roz≈°√≠≈ôen√≠ pro p≈ôipojen√≠ k WiFi je pou≈æ√≠v√°n√≠ ulo≈æen√©ho nastaven√≠ (v `config/wifi.json`).
Nastaven√≠ WiFi se prov√°d√≠ pomoc√≠ [setup()](../install/#setup-nastaveni-systemu)

```python
from utils.wifi_connect import WiFiConnect

net = WiFiConnect()
net.connect()
```

```python
if not net.isconnected()
    # hard reconect
    net.sta_if.disconnect()
    net.connect()
```

V p≈ô√≠padƒõ "z√°va≈ænƒõj≈°√≠ho probl√©mu" s p≈ôipojen√≠m nƒõkdy pom≈Ø≈æe a≈æ "tvrd√Ω" [reset](#reset).
```python
# hard reset
reset()
```

Vyu≈æit√≠ [Octopus FrameWork](/framework) na maximum - k p≈ôipojen√≠ k nƒõkter√© z ulo≈æen√Ωch WiFi postaƒç√≠ p≈ô√≠kaz `w()`:

```python
from utils.octopus_lib import w
w()
```

Variantnƒõ s dostupn√Ωmi metodami:

```python
wc = w()
ip = wc.sta_if.ifconfig()[0]
...
wc.isconnected()
```

A opaƒçn√Ω extr√©m - klasick√© p≈ôipojen√≠ k s√≠ti s p≈ôed√°n√≠m parametr≈Ø `ssid` (n√°zev) a `password` (heslo):

```python
import network
wlan = network.WLAN(network.STA_IF)
wlan.active(True)
wlan.connect('ssid', 'password')
```

Umo≈æn√≠ n√°m (od verze v1.16 on 2021-08-09) skenovat celu s√≠≈•:

```python
llan = wlan.scan() # list
for i in llan:
    print(i[0],i[2])
```

---


### ![hwsoc](img/bits.png){: style="width:28px" } Bits
Pro pr√°ci s jednotliv√Ωmi **bity**. `B1 = 0b11111001`. Bitov√© operace jsme si museli do Pythonu trochu doladit, aby se s nimi pracovalo l√©pe a intuitivnƒõ. **Pou≈æ√≠van√© metody:**

- `neg(B1)` pro negaci - vrac√≠ *0b00000110*
- `reverse()` obr√°cen√≠ po≈ôad√≠ bit≈Ø - vrac√≠ *0b1001111*
- `get_bit(B1,1)` pro z√≠sk√°n√≠ stavu jednoho bitu > 0
- `set_bit(B1,1)` pro nastaven√≠ stavu jednoho bitu
- `int2bin()` pomocn√° funkce pro p≈ôevod ƒç√≠sla na bin√°rn√≠

Zdrojov√Ω k√≥d knihovny: [utils/bits](https://github.com/octopusengine/octopuslab/blob/master/esp32-micropython/utils/bits/__init__.py)

```python
from components.bits import neg
B1 = 0b11111001
neg(B1) # > 0b00000110

```

---

### ![hwsoc](img/mchtr.png){: style="width:28px" } Transform

Pomocn√© funkce pro mechatroniku, zamƒõ≈ôen√© na transformace sou≈ôadnicov√Ωch syst√©m≈Ø a z√°klady inversn√≠ kinematiky.

- `Point2D()` class p2 = (x,y) | p2.x, p2.y
- `distance2D(p1, p2, rr = 3)` vzd√°lenost dvou bod≈Ø v rovinƒõ
-  *vyu≈æ√≠v√° se round - zaokrouhlen√≠ na urƒçit√Ω poƒçet m√≠st:* `rr` = 3 
- `polar2cart(r, alfa, rr = 3)`
- `cart2polar(point)`
- `def cosangle(opp, adj1, adj2)`
- `move_2d_line(p_start, p_stop, steps = 300, max_dist = 100)`
- `invkin2_1(point2d, rr = 6)` inversn√≠ kinematika 1
- `invkin2(point2d, angleMode=DEGREES)`
- `Point3D()` class p3 = [x,y,z]
- `invkin3(point3d, angleMode=DEGREES)`
- `distance3()` vzd√°lenost dvou bod≈Ø v prostoru
- ...

```python
from utils.transform import Point2D, polar2cart, cosangle
p1 = Point2D(1,3)
print(p1)   # (1,3)
print(p1.x) # 1
print(p1.y) # 3
p1.x, p1.y = polar2cart(10, 0)
print(p1)
...
```


```python
from utils.transform import move_servo2, cosangle

...
def move_servo2(p1, p2, delay = delay):
    steps = move_2d_line(p1, p2)
    for step in steps:
        alfa = cosangle(step[0], dist, dist)[0]
        beta = cosangle(step[1], dist, dist)[0]
        print(step, alfa, beta)

        s1.set_degree(alfa)
        s2.set_degree(beta)
        sleep_ms(delay)

p1 = 0, 0 # strart point
p2 = 50, 50 # stop point
move_servo2(p1, p2)

```
V√≠ce pl√°nujeme v samostatn√© sekci [inversn√≠ kinematika](/inv_kinematics)

---


### ![hwsoc](img/database.png){: style="width:28px" } Database
ESP d√≠ky pamƒõti umo≈æ≈àuje bez nads√°zky i z√°kladn√≠ pr√°ci s datab√°z√≠.
Zamƒõ≈ô√≠me se na dvƒõ z√°kladn√≠: lok√°ln√≠ `btree` a vzd√°len√© `MySQL`, `InfluxDB`.

```python
from utils.database.btreedb import BTreeDB
db = BTreeDB("test")
db.addOne("one","1")
db.listAll()
```

Zv√≠davƒõj≈°√≠m doporuƒçujeme odkaz na pr√°ci s daty a datab√°ze ü°í [Workshop Python DATA](/ws-python-data)

---

### ![hwsoc](img/database.png){: style="width:28px" } MQTT

- MQTT - jako pub-sub
- MQTT broker - na RPi
- orchestr√°tor NodeJS
- vyu≈æit√≠ v IoT
---

### ![hwsoc](img/database.png){: style="width:28px" } InfluxDB

Pro zobrazov√°n√≠ dat v **Grafanƒõ** pr≈Øbƒõ≈ænƒõ pos√≠l√°me √∫daje na vzd√°len√Ω server, kter√Ω je ukl√°d√° do datab√°ze **InfluxDB**.
Jednoduch√Ω p≈ô√≠klad jednor√°zov√©ho odesl√°n√≠ jedn√© hodnoty (**timestamp** - datum a ƒças se p≈ôidaj√≠ p≈ôi ukl√°d√°n√≠ automaticky):

```python
from utils.database.influxdb import InfluxDB

influx = InfluxDB("https://your.server.com/grafana/influx/user...", "user_db", "i_usr", "i_psw", "i_measurement")

value = 25.6  # zde je treba cist hodnotu z nejakeho senzoru, napr. teplomeru
influx.write(temperature=value)
...
```

Metoda `write` mus√≠ dostat pojmenovan√© parametry (key word arguments - tzv. kwargs), kter√© se v Influxu pou≈æij√≠, jako jednotliv√© fieldy. V p≈ô√≠kladu naho≈ôe je to `temperature`, kam ukl√°d√°me hodnotu ze sensoru.

Funkƒçn√≠ uk√°zka nap≈ô: [examples/influxdb_disp7_therm.py](https://github.com/octopusengine/octopuslab/blob/master/esp32-micropython/examples/influxdb_disp7_therm.py)

---

Abychom mohli pou≈æ√≠t identick√Ω program s minimem zmƒõn,
vyu≈æijeme konfiguraƒçn√≠ soubor, naƒçteme pomoc√≠ `fromconfig()`. A tak√© nechceme m√≠t **p≈ô√≠stupov√© √∫daje ve zdrojov√©m k√≥du**! 

```python
from utils.database.influxdb import InfluxDB

influx = InfluxDB.fromconfig()

temp = ...
influx.write(temperature=temp)
```

`fromconfig()` bere volitelnƒõ jako prvn√≠ parametr, n√°zev konfiguraƒçn√≠ho souboru, default je `"influxdb"`, tedy soubor `config/influxdb.json`.

P≈ô√≠klad obsahu je:

```json
{"influxdb_url": "https://parallelgarden.surikata.info:8086", "influxdb_pass": "heslo", "influxdb_name": "nazev_db", "influxdb_user": "uzivatel", "influxdb_measurement": "meteo", "influxdb_tags": {"location": "balkon"}}
```

V√≠ce o vytv√°≈ôen√≠ a editaci konfiguraƒçn√≠ch soubor≈Ø ü°í [Config](#config)

---


## OCTOPUS Lib

### LCD

Knihovna t≈ôet√≠ strany pro ovl√°d√°n√≠ dvou nebo ƒçty≈ô-≈ô√°dkov√©ho LCD displeje p≈ôipojen√©ho k `i2c` expand√©ru, byla p≈Øvodnƒõ urƒçena pro star≈°√≠ ESP8266, ale funguje n√°m bez √∫prav i pro ESP32 (proto≈æe komunikaƒçn√≠ protokol na i2c se nemƒõn√≠).

Z√°kladem v nastaven√≠ je: poƒçet ≈ô√°dk≈Ø `rows` - 1/2/4, a poƒçet "sloupc≈Ø" `col` odpov√≠d√° poƒçtu znak≈Ø na ≈ô√°dku.
Uk√°zka pro displej `2x16` - s hlavn√≠ metodou `putstr(STRING)`.

```python
# from machine import I2C , Pin
# i = I2C(scl=Pin(22), sda=Pin(21), freq=100000)
from utils.octopus_lib import i2c_init
i2c = i2c_init()
# i2c.scan() # > [39]
from lib.esp8266_i2c_lcd import I2cLcd
lcd = I2cLcd(i2c, 39, 2, 16) # addr, rows, col
lcd.putstr("octopusLab") # write text
...
```

Pomoc√≠ speci√°ln√≠ch znak≈Ø (u≈æ implementovan√Ωch) lze vykreslit nap≈ô√≠klad stupnƒõ Celsia (pro zobrazov√°n√≠ teploty):

```python
lcd.putstr(chr(223))
```

Nastaven√≠ kurzoru `move_to()` a uk√°zka zobrazen√≠ hodin s blikaj√≠c√≠ dvojteƒçku:

```python
def clock():
    lcd.move_to(5,1)
    lcd.putstr(get_hhmm(":"))
    sleep(0.5)
    lcd.move_to(5,1)
    lcd.putstr(get_hhmm(" "))
    sleep(1)
```


V na≈°em podadres√°≈ôi `/assets` m√°me v souboru `lcd_chars.py` tabulky nƒõkter√Ωch "novƒõ definovan√Ωch" znak≈Ø pro LCD:

```python
import assets.lcd_chars as ch

from utils.octopus import lcd2_init
lcd = lcd2_init()

lcd.custom_char(0, ch.happy)
lcd.putchar(chr(0))

lcd.custom_char(1, ch.clock)
lcd.putchar(chr(1))

...
```
---


### ST7735

Barevn√Ω displej TFT 128x160, kter√Ω ale vy≈æaduje p≈ôi pr√°ci s Micropythonem vƒõt≈°√≠ pamƒõ≈•.

Doporuƒçen√© p≈ôipojen√≠ k `ESP32board`:
```
Display | ESP32board
------------------------
1-RST   | PWM2 (16)
2-CS    | SCE0 (5)
3-D/C   | PWM1 (17)
4-DIN   | SPI_MOSI (23)
5-CLK   | SPI_CLK (18)
6-UCC   | 5V
7-BL    | 3V3
8-GND   | GND
```

**Nov√° verze**

```python
from ST7735 import TFT, TFTColor
from sysfont import sysfont
from machine import SPI, Pin
from time import sleep_ms, ticks_ms
from math import pi
from utils.octopus_lib import w # need connection for FTP

SPI_SCLK = 18
SPI_MISO = 19
SPI_MOSI = 23

DC = 17   # PWM1
RST = 16  # PWM2
CS = 5    # SCE0

print("--- TFT 128x160px test ---")

spi = SPI(2, baudrate=20000000, polarity=0, phase=0, sck=Pin(SPI_SCLK), mosi=Pin(SPI_MOSI), miso=Pin(SPI_MISO))
tft=TFT(spi, DC, RST, CS)
tft.initr()
tft.rgb(True)

tft.fill(TFT.BLACK)
v = 30
tft.text((0, v), "octopus LAB (1)", TFT.RED, sysfont, 1, nowrap=True)
v += sysfont["Height"]

tft.fill(TFT.BLACK)
tft.rotation(1)
tft.text((0, 0), "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur adipiscing ante sed nibh tincidunt feugiat. Maecenas enim massa, fringilla sed malesuada et, malesuada sit amet turpis. Sed porttitor neque ut ante pretium vitae malesuada nunc bibendum. ", TFT.WHITE, sysfont, 1)
sleep_ms(2000)

...

```

**P≈Øvodn√≠ star≈°√≠ verze**

```python
from machine import Pin, SPI, SDCard
from time import sleep, sleep_ms

from utils.pinout import set_pinout
pinout = set_pinout()

import framebuf
from lib import st7735
from lib.rgb import color565

print("spi.TFT 128x160 init >")
spi = SPI(1, baudrate=10000000, polarity=1, phase=0, sck=Pin(pinout.SPI_CLK_PIN), mosi=Pin(pinout.SPI_MOSI_PIN))
ss = Pin(pinout.SPI_CS0_PIN, Pin.OUT)

rst = Pin(16, Pin.OUT) #PWM2 (16) / DEv3(27)
cs = Pin(5, Pin.OUT)   #SCE0 (5)
dc = Pin(26, Pin.OUT)  #PWM1 (17) /  IO26

tft = st7735.ST7735R(spi, cs = cs, dc = dc, rst = rst)

print("spi.TFT framebufer >")
fb = framebuf.FrameBuffer(bytearray(tft.width*tft.height*2), tft.width, tft.height, framebuf.RGB565)
fbp = fb.pixel

fb.line(128,0,0,166,color565(0,255,0))
tft.blit_buffer(fb, 0, 0, tft.width, tft.height)
...
```

ü°í [pinout](#pinout)

[examples/test_tft128x160.py](https://github.com/octopusengine/octopuslab/blob/master/esp32-micropython/examples/test_tft128x160.py)

---


### hcsr04

Ultrazvukov√Ω mƒõ≈ôiƒç vzd√°lenosti.

```python
from time import sleep
from util.pinout import set_pinout

pinout = set_pinout()

from hcsr04 import HCSR04
print("ulrasonic distance sensor")
echo = HCSR04(trigger_pin=pinout.PWM2_PIN, echo_pin=pinout.PWM1_PIN)

while True:
    echo_cm = echo.distance_cm()
    print(echo_cm)
    sleep(1)

```

ü°í [pinout](#pinout)

[examples/ultrasonic.py](https://github.com/octopusengine/octopuslab/blob/master/esp32-micropython/examples/ultrasonic.py)

---


### ![hwsoc](img/database.png){: style="width:28px" } pubsub

N√°stroj pro p≈ôed√°v√°n√≠ hodnot mezi nez√°visl√Ωmi komponenty v r√°mci projektu a to i v samostatnƒõ bƒõ≈æ√≠c√≠ch vl√°knech. Pracuje na principu **publish and subscribe**. Fork z [basecue/micropython-pubsub](https://github.com/basecue/micropython-pubsub).

Zdrojov√Ω k√≥d knihovny: [./lib/pubsub.py](https://github.com/octopusengine/octopuslab/blob/master/esp32-micropython/lib/pubsub.py)

Z√°klad pr√°ce: jedno vl√°kno (nebo ƒç√°st programu) publikuje z√≠skan√© hodnoty metodou `publish` kde parametrem je `topic` a hodnota `value`. Nap≈ô√≠klad`pubsub.publish('topic', value)`. (value m≈Ø≈æe b√Ωt libovoln√Ω objekt). V jednoduch√© uk√°zce  jednou za vte≈ôinu generujeme n√°hodn√° ƒç√≠sla, kter√° "publikujeme". (pozor, pou≈æ√≠v√°me `while True:` - je to blokuj√≠c√≠, lep≈°√≠ je pou≈æ√≠t `timer`)


```python
from time import sleep
from os import urandom
import pubsub


print("start: ps_random.py")

while True:
    value =  int(urandom(1)[0])
    print("rnd.: ", value)
    pubsub.publish('value', value)
    sleep(1)
```

Protistrana je odeb√≠r√° / naslouch√°.
A m≈Ø≈æe je t≈ôeba zobrazovat na displeji:

```python
import pubsub
from utils.octopus import disp7_init

d7 = disp7_init()  # 8 x 7segment display init


@pubsub.subscriber("value")
def display_num(value):
    d7.show(value)
```

ü°í [Disp7](#disp7)

Uk√°zky jsou z vybran√Ωch p≈ô√≠klad≈Ø pro pubsub: 
[examples/pubsub](https://github.com/octopusengine/octopuslab/tree/master/esp32-micropython/examples/pubsub)

---


### ![hwsoc](img/bt.png){: style="width:28px" } BLE
Jeliko≈æ obecn√° problematika BLE (Bluetooth low energy) je pomƒõrnƒõ obs√°hl√°, tak i modul BLE je dost robustn√≠. Zahrnuje nƒõkolik ƒç√°st√≠: `blesync`, `blesync_client`, `blesync_server` a samostatn√Ω modul `blesync_uart`. Ka≈ædop√°dnƒõ funguje velmi dob≈ôe a snahou bylo, aby pr√°ce s n√≠m byla srozumiteln√° a p≈ôitom umo≈ænila vyu≈æ√≠t v≈°echny mo≈æn√© v√Ωhody, kter√© BLE obecnƒõ p≈ôin√°≈°√≠.
Projekt m√° sv≈Øj vlastn√≠ repozit√°≈ô: [/blesync](https://github.com/blesync).

N√°sleduj√≠c√≠ p≈ô√≠klad umo≈æn√≠ z mobiln√≠ aplikace nal√©zt ESP za≈ô√≠zen√≠ jako `octopus-led-UID`, kde UID je ƒç√°s unik√°tn√≠ho ID, kter√© m√° ka≈æd√© ESP.
Pomoc√≠ mobiln√≠ aplikace ≈°ipkami nahoru (Up) a dol≈Ø (DOWN) pak ovl√°d√°me vestavƒõnou Led diodu.


```python
import blesync_server
import blesync_uart.server
import utils.ble.bluefruit as bf

from shell.terminal import getUid
uID5 = getUid(short=5)

from time import sleep
from components.led import Led
led = Led(2)


@blesync_uart.server.UARTService.on_message
def on_message(service, conn_handle, message):
    if message == bf.UP:
        led.value(1)
    if message == bf.DOWN:
        led.value(0)
    if message == bf.RIGHT:
        led.toggle()

    service.send(conn_handle, message)

_connections = []


devName = 'octopus-led-'+uID5
print("BLE ESP32 device name: " + devName)

server = blesync_server.Server(devName, blesync_uart.server.UARTService)
server.start()

```


#### ![hwsoc](img/mobplg.png){: style="width:28px" } Mobiln√≠ aplikace pro BLE
Pou≈æ√≠v√°me **Bluefruit connect** od spoleƒçnosti Adafruit. Jeden z odkaz≈Ø na [play.google.com/store/apps](https://play.google.com/store/apps/details?id=com.adafruit.bluefruit.le.connect&hl=cs)

Vytvo≈ôili jsme si pomocnou knihovnu pro "p≈ôekl√°d√°n√≠" jimi definovan√Ωch k√≥d≈Ø, kter√° je zat√≠m zde `./utils/ble/blefruit.py`:

```python
UP =   b'!B516'
DOWN = b'!B615'
LEFT = b'!B714'
RIGHT = b'!B813'
...
```

S touto knihovnou pak pracujeme takto:
```python
import utils.ble.bluefruit as bf
...
    if message == bf.UP:
        led.value(1)
    if message == bf.DOWN:
        led.value(0)
```

---


## Ostatn√≠ podp≈Ørn√© moduly

### ![hwsoc](img/database.png){: style="width:28px" } Config

Micropython m√° elegantnƒõ propacovanou pr√°ci se soubory (nahr√°v√°n√≠ a ƒçten√≠) a i s `json` form√°tem, proto jsme toho vyu≈æili pro extern√≠ konfiguraƒçn√≠ soubory. V adres√°≈ôi `/config` jsou nahr√°ny jednotliv√© "jsony", kter√© v sobƒõ obsahuj√≠ nƒõjak√© konstanty, nastaven√≠ a podobnƒõ. Proto m≈Ø≈æeme dan√Ω projekt dynamicky konfigurovat. Vyu≈æ√≠v√°me to i v nastaven√≠ PIN≈Ø jednotiv√Ωch za≈ô√≠zen√≠ `device.json` nebo pro ulo≈æen√≠ p≈ô√≠stup≈Ø k WiFi `wifi.json`.

Zdrojov√Ω k√≥d knihovny: [./config/__init__.py](https://github.com/octopusengine/octopuslab/blob/master/esp32-micropython/config/__init__.py)

#### Jednotliv√© **metody** pro z√°kladn√≠ varianty pou≈æ√≠v√°n√≠:

1) Vytvo≈ôen√≠m pomoc√≠ konstruktoru: `myConfig = Config("myConfigFile",keys)`        
Vy≈æaduje p≈ôedefinici kl√≠ƒçov√Ωch "metrik": `keys = ["tempMax","tempMin"]`

- `setup()`
- `print()` # for keys

Mƒõjme uk√°zkov√Ω projekt **termostat**, kter√Ω na z√°kladƒõ zmƒõ≈ôen√© teploty pust√≠ buƒè topen√≠, nebo chlazen√≠ (ventil√°tor). Volitelnƒõ si m≈Ø≈æeme v programu definovat `keys`, kde m√°me ulo≈æeny n√°zvy podstatn√Ωch konstant. Instanci pak vytv√°≈ô√≠me `conf = Config("your_file", keys)`, kde "your_file" je n√°zev - nejƒçastƒõji shodn√Ω s n√°zvem projektu. Nap≈ô√≠klad "termostat". Se souborem se pak d√° pracovat nƒõkolika metodami, nap≈ô√≠klad: `setup()` (interaktivn√≠ m√≥d - pou≈æ√≠v√°me nejƒçastƒõji), `create_from_query()`, `set()`, `save()` ... 

```python
>>> from config import Config
>>> keys = ["tempMax","tempMin"]
>>> conf = Config("termostat", keys) # > config/termostat.json
>>> conf.setup()

==================================================
        S E T U P - config/termostat.json
==================================================
[ 1] -          tempMax -
[ 2] -          tempMin -
[q] - Quit from json setup
==================================================
select:

```

Vid√≠me, ≈æe nastaven√≠ `config` je snadn√©. Staƒç√≠ vyplnit nebo modifikovat interaktivn√≠ tabulku.


2) Vytvo≈ôen√≠m pomoc√≠ konstruktoru bez `keys`: `myConfig = Config("myConfigFile")`

- `print_all()`
- `get("key")`
- `set("key",value)`
- `create_from_query("a=1&b=2")` # key1 = "a", value1 = 1 ...
- `save()`


```python
# vytvo≈ôen√≠ konfigu: a = 1, b = 2
>>> conf = Config("your_config")
>>> conf.create_from_query("a=1&b=2")
{'a': '1', 'b': '2'}
>>> conf.set("c",3)
>>> conf.save()
Writing new config item to file config/your_config.json
>>> conf.print_all()
-----------------------------------------
                  a - 1
                  c - 3
                  b - 2
-----------------------------------------
>>>
```

---

Ve sv√©m programu pak `config` pou≈æijeme n√°sledovnƒõ:

```python
from config import Config
conf = Config("your_config")
a =  conf.get("a") # 1
b =  conf.get("b") # 2

```

Pro lep≈°√≠ pochopen√≠ datov√Ωch struktur nastudujte ü°í [/ws-python-data](../ws-python-data/)

---


### ![hwsoc](img/database.png){: style="width:28px" } octopus_lib

#### I2C
`i2c_init()`

```python
>>> from utils.octopus_lib import i2c_init
>>> i2c = i2c_init()
>>> i2c.scan()
```

```python
# I2C address:
OLED_ADDR = 0x3c
LCD_ADDR = 0x27
bhLight = 0x23
bh2Light = 0x5c
tslLight = 0x39

# PCF8574           PCF8574A
# AAA - hex (dec)
# 210
# 000 - 0x20 (32)   0x38 (56)
# 001 - 0x21 (33) * 0x39 (57)
# 010 - 0x22 (34)   0x3A (58)
# 011 - 0x23 (35) * 0x3B (59)
# 100 - 0x24 (36)   0x3C (60)
# 101 - 0x25 (37)   0x3D (61)
# 110 - 0x26 (38)   0x3E (62)
# 111 - 0x27 (39)   0x3F (63)
# * ROBOTboard
```

```python
# nƒõkter√© dal≈°√≠ z√°kladn√≠ metody
ADDR = 42
i2c.writeto(ADDR, b'123')  # write 3 bytes to slave with 7-bit address 42
i2c.readfrom(ADDR, 8)      # read 8 bytes from slave with 7-bit address 42

i2c.readfrom_mem(ADDR, 8, 3) # ...

```

Odkaz na origin√°ln√≠ Micropython dokumentaci k **I2C** ü°í  https://docs.micropython.org/en/latest/library/machine.I2C.html

---
 
#### SPI
`spi_init()`

```python
from machine import Pin, SPI
from components.display7 import Display7
## from utils.pinout import set_pinout
from utils.octopus_lib import spi_init

print("--- spi-init ---")
## spi = SPI(1, baudrate=10000000, polarity=1, phase=0, sck=Pin(pinout.SPI_CLK_PIN), mosi=Pin(pinout.SPI_MOSI_PIN))
spi = spi_init()

ss = Pin(pinout.SPI_CS0_PIN, Pin.OUT)
#spi.deinit() #print("spi > close")
...
```

```python
# nƒõkter√© dal≈°√≠ z√°kladn√≠ metody
SPI.deinit()
SPI.read(nbytes, write=0)
SPI.readinto(buf, write=0)
SPI.write(buf)
SPI.write_readinto(write_buf, read_buf)
...

```

Odkaz na origin√°ln√≠ Micropython dokumentaci k **SPI** ü°í https://docs.micropython.org/en/latest/library/machine.SPI.html

---

#### RTC

Modul re√°ln√©ho ƒçasu m√° Micropython v posledn√≠ verzi doplnƒõn i o ntp modulem `ntptime`.

Co se skr√Ωv√° v ü°í [ntptime](https://github.com/micropython/micropython/blob/master/ports/esp8266/modules/ntptime.py)?
P≈ôedev≈°√≠m metoda `settime()`, pomoc√≠ kter√© z√≠sk√°me p≈ôesn√Ω ƒças ze serveru `pool.ntp.org`.


```python
from ntptime import settime
from machine import RTC
from utils.octopus_lib import w, get_hhmm, setlocal


rtc = RTC()
w() # p≈ôipojen√≠ k internetu
settime()
print(get_hhmm(rtc))

# + 2 h.
setlocal(2)
print(get_hhmm(rtc))

```

Zdroj uk√°zky ü°í [test_rtc_ntp.py](https://github.com/octopusengine/octopuslab/blob/master/esp32-micropython/examples/test_rtc_ntp.py)


Odkaz na origin√°ln√≠ Micropython dokumentaci k **RTC** ü°í https://docs.micropython.org/en/latest/library/machine.RTC.html

---


### ![hwsoc](img/database.png){: style="width:28px" } pinout

Pr√°ci s PINy (*"no≈æiƒçky" kontroleru*) n√°m ulehƒçuje p≈ôednastanen√Ω **pinout**, kter√Ω je ulo≈æen√Ω v konfiguraƒçn√≠m souboru. Konfiguraƒçn√≠ soubory pro jednotliv√© hw moduly jsou v samostatn√©m adres√°≈ôi `/pinouts`. Podle toho, jakou m√°me HW platformu, m√°me p≈ôesnƒõ sv√°z√°ny konstanty (ƒç√≠sla PIN≈Ø) s jejich n√°zvy.
Vybran√© soubory zapojen√≠ pin≈Ø jsou na samostatn√© str√°nce ü°í [pinouts](/pinouts).

Zdrojov√Ω k√≥d knihovny: ü°í [utils/pinout](https://github.com/octopusengine/octopuslab/blob/master/esp32-micropython/utils/pinout.py)

**Princip je jednoduch√Ω:**
m√°me definov√°ny ƒç√≠seln√© konstanty (v programu se nemƒõn√≠c√≠ ƒç√≠sla), nap≈ô√≠klad pro vestavƒõnou Led diodu: `BUILT_IN_LED = const(ƒç√≠slo)`. **ƒå√≠slo** je zde ƒç√≠slo PINu a m≈Ø≈æe se li≈°it podle dan√© desky (deska je nastavena p≈ô√≠kazem `>>> setup()`).
Tato konstanta je ulo≈æena v souborech `pinouts/file_name`. Pro ROBOTboart je to `2`, tak≈æe v souboru pro definici pin≈Ø najdete ≈ô√°dek `BUILT_IN_LED = const(2)`. V√Ωchoz√≠ spoleƒçn√© piny jsou v [/pinouts/olab_esp32_base.py](https://github.com/octopusengine/octopuslab/blob/master/esp32-micropython/pinouts/olab_esp32_base.py) a ROBOTboard je p≈ôeb√≠r√°.


Jak se s modulem pinout pracuje? M≈Ø≈æete si zkusit z termin√°lu Micropythonu: `>>>`

```python
>>> from utils.pinout import set_pinout
>>> pinout = set_pinout()
```
A u≈æ m√°me dostupn√© piny na `pinout.NAZEV_PINU`, daj√≠ se zjistit i osatn√≠ PINy, po `pinout` teƒçka `TAB`:

```python
>>> pinout.
__class__       __name__        const           __file__
WS_LED_PIN      ONE_WIRE_PIN    PIEZZO_PIN      MOTOR_12EN
MOTOR_34EN      MOTOR_1A        MOTOR_2A        MOTOR_3A
MOTOR_4A        ANALOG_PIN      PWM1_PIN        PWM2_PIN
PWM3_PIN        SERVO_MIN       SERVO_MAX       I39_PIN
DEV1_PIN        DEV2_PIN        BUILT_IN_LED    HALL_SENSOR
I2C_SCL_PIN     I2C_SDA_PIN     SPI_CLK_PIN     SPI_MISO_PIN
SPI_MOSI_PIN    SPI_CS0_PIN     RXD0            TXD0
BUTT1_PIN       BUTT2_PIN       BUTT3_PIN       DEV3_PIN
...

>>> pinout.BUILT_IN_LED
2
```
Vid√≠me, ≈æe pro `BUILT_IN_LED` n√°m "dohled√°" ƒç√≠slo deklarovan√© `2`, tak≈æe se to d√° pou≈æ√≠t:


```python
led = Led(pinout.BUILT_IN_LED)      # BUILT_IN_LED = 2
```
je shodn√© s:
```python
led = Led(2)
```
ale ƒç√≠slo `2` si nemus√≠me pamatovat, nav√≠c u r≈Øzn√Ωch modul≈Ø se m≈Ø≈æe li≈°it.

*Cel√° uk√°zka pro blik√°n√≠ vestavƒõn√© Ledky na r≈Øzn√Ωch modulech - m≈Ø≈æe b√Ωt na PINu `2` nebo tak√© na `15`... nebo √∫plnƒõ jin√©m.
A my toto ƒç√≠slo p≈ôi spr√°vn√© konfiguraci modulu (desky) nemus√≠me ≈ôe≈°it a k vestavƒõn√© Ledce p≈ôistupujeme n√°zvem PINu: `BUILT_IN_LED`.*

```python
from components.led import Led
from utils.pinout import set_pinout   # import library

pinout = set_pinout()   # set board pinout

led = Led(pinout.BUILT_IN_LED)

# start main loop
while True:
    led.blink()
```
ü°í [Led](#led)

---


### ![hwsoc](img/database.png){: style="width:28px" } Dekor√°tor

Mo≈æn√° jste si v nƒõkter√Ωch na≈°ich uk√°zk√°ch v≈°imnuli speci√°ln√≠ho pou≈æit√≠ `@` p≈ôed definic√≠ funkce, nap≈ô√≠klad v ü°í [pubsub](#pubsub)
```python
@pubsub.subscriber("value")
def display_num(value):
    d7.show(value)
```


nebo v ü°í [button](#button)
```python
@led_button.on_press
def on_press_top_button():
    print("on_press_top_button")
    built_in_led.on()
```


Dekor√°tor v Pythonu je **funkce**, kter√° dostane jeden argument (funkci) a vr√°t√≠ jednu hodnotu - opƒõt funkci, kter√° je modifikovanou verz√≠ funkce p≈Øvodn√≠. *P≈Øvodn√≠ funkce ja takzvanƒõ "odekorovan√°".*

Pou≈æit√≠ dekor√°tor≈Ø velmi zjednodu≈°√≠ a zp≈ôehlen√≠ v√°≈° k√≥d. Pou≈æ√≠v√° se na registraci, modifikaci a podobnƒõ. 


```python
@dekorator
def funkce():
    pass

# je stejn√© jako:

def funkce():
    pass
funkce = dekorator(funkce)
```



Speci√°ln√≠ `@octopus_debug` dekor√°tor ü°í [/octopus_decor.py](https://github.com/octopusengine/octopuslab/blob/master/esp32-micropython/utils/octopus_decor.py) vrac√≠ nap≈ô√≠klad ƒças, kter√Ω trvalo proveden√≠ "odekorovan√©" funkce.

```python
@octopus_debug
def yourFunc(): 
    ...
```

---


### Zrychlen√≠ pr√°ce procesoru

Zkou≈°√≠me dekor√°tory `@micropython.native` nebo `@micropython.viper` - podrobnƒõji pops√°no p≈ô√≠mo na str√°nk√°ch ü°í [micropython/reference/..speed_python](http://docs.micropython.org/en/v1.9.3/pyboard/reference/speed_python.html)


Jak se d√° rychlost testovat (je pou≈æit dal≈°√≠ dekor√°tor `@octopus_debug` - ten vrac√≠ ƒças bƒõhu funkce):


```python
from utils.octopus_decor import octopus_debug


@octopus_debug
def test1():
    for i in range(10000000):
        xx=i

@octopus_debug
@micropython.native
def test2_native():
    for i in range(10000000):
        xx=i

@octopus_debug
@micropython.viper
def test3_viper():
    for i in range(10000000):
        xx=i



>>> test1()
=== function name:  test1
=== duration (sec.) ---> 41

...

>>> test2_native()
=== function name:  test2
=== duration (sec.) ---> 6

...

test3_viper()
```

---

## Web server - IDE - jednoduch√© ovl√°d√°n√≠

Jsme vyƒçlenili samostatnƒõ - zat√≠m zde: [micropython-web-ide](https://www.octopuslab.cz/micropython-web-ide/)

### Web server

ESP32 m√° dostateƒçn√Ω v√Ωkon, aby na nƒõm mohl bƒõ≈æet jednoduch√Ω **webov√Ω server** (server s jednoduch√Ωmi "html" str√°nkami, k kter√©mu se v lok√°ln√≠ s√≠ti p≈ôipoj√≠me p≈ôes IP ESPƒçka)

```python
>>> from utils.octopus_lib import w
>>> from utils.octopus import web_server
>>> w()
>>> web_server()

```